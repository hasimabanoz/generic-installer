package com.generic.util;import java.io.File;import java.io.FileFilter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.Writer;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;import org.apache.log4j.FileAppender;import org.apache.log4j.helpers.CountingQuietWriter;import org.apache.log4j.helpers.LogLog;import org.apache.log4j.spi.LoggingEvent;public class GenericDatedFileAppender extends FileAppender {	SimpleDateFormat datePatternFormat = new SimpleDateFormat("_yyyyMMdd_HHmmss", Locale.ENGLISH);	protected long maxFileSize = 1;	protected int maxBackupIndex = 100;	protected int maxNumberOfDays = 30;	private long nextRollover = 0;	private boolean compressBackups = true;	private String logDirectory = "logs";	private String logPrefix = "";	private String logSuffix = ".log";	/**	 *	 * The File representation of the directory in which log files are created.	 */	private File m_path = null;	private long nextCheck = System.currentTimeMillis() - 1;	Date lastCheck = new Date();	public long getMaxFileSize() {		return maxFileSize;	}	public void setMaxFileSize(long maxFileSize) {		this.maxFileSize = maxFileSize * 1024 * 1024;	}	public boolean isCompressBackups() {		return compressBackups;	}	public void setCompressBackups(boolean compressBackups) {		this.compressBackups = compressBackups;	}	public String getLogDirectory() {		return logDirectory;	}	public void setLogDirectory(String logDirectory) {		this.logDirectory = logDirectory;	}	public String getLogPrefix() {		return logPrefix;	}	public void setLogPrefix(String logPrefix) {		this.logPrefix = logPrefix;	}	public int getMaxNumberOfDays() {		return maxNumberOfDays;	}	public void setMaxNumberOfDays(int maxNumberOfDays) {		this.maxNumberOfDays = maxNumberOfDays;	}	public String getDirectory() {		return logDirectory;	}	public void setDirectory(String directory) {		logDirectory = directory;	}	public String getPrefix() {		return logPrefix;	}	public void setPrefix(String prefix) {		logPrefix = prefix;	}	public String getSuffix() {		return logSuffix;	}	public void setSuffix(String suffix) {		logSuffix = suffix;	}	// ----------------------------------------------------------- Constructors	public GenericDatedFileAppender() {		super();		StringBuilder log = new StringBuilder();		log.append("\nmaxFileSize : ").append(getMaxFileSize());		log.append("\nmaxNumberOfDays :").append(getMaxNumberOfDays());		log.append("\ncompressBackups :").append(isCompressBackups());		log.append("\nlogDirectory :").append(getLogDirectory());		log.append("\nlogPrefix :").append(getLogPrefix());		LogLog.debug("GeniusDatedFileAppender start Probs : \n" + log.toString());	}	public GenericDatedFileAppender(String directory, String prefix, String suffix) {		logDirectory = directory;		logPrefix = prefix;		logSuffix = suffix;		activateOptions();	}	/**	 *	 * Called once all options have been set on this Appender. Calls the	 *	 * underlying FileLogger's start() method.	 */	@Override	public void activateOptions() {		m_path = new File(logDirectory);		if (!m_path.isAbsolute()) {			m_path = new File(logDirectory);		}		m_path.mkdirs();		if (m_path.canWrite()) {			lastCheck.setTime(System.currentTimeMillis());		}	}	/**	 *	 * Called by AppenderSkeleton.doAppend() to write a log message formatted	 *	 * according to the layout defined for this appender.	 */	@Override	public void append(LoggingEvent event) {		if (layout == null) {			errorHandler.error("No layout set for the appender named [" + name + "].");			return;		}		long now = System.currentTimeMillis();		if (fileName != null && qw != null) {			long size = ((CountingQuietWriter) qw).getCount();			if (size >= maxFileSize && size >= nextRollover) {				cleanupAndRollOver();			} else if (now >= nextCheck) {				cleanupAndRollOver();			}		} else {			cleanupAndRollOver();		}		if (qw == null) { // should never happen			errorHandler.error("No output stream or file set for the appender named [" + name + "].");			return;		}		subAppend(event);	}	private long getNextCheckMillis() {		Calendar cal = new GregorianCalendar();		cal.setTime(new Date());		cal.set(Calendar.HOUR_OF_DAY, 0);		cal.set(Calendar.MINUTE, 0);		cal.set(Calendar.SECOND, 0);		cal.set(Calendar.MILLISECOND, 0);		cal.add(Calendar.DATE, 1);		return cal.getTime().getTime();	}	void rollOver() {		String datestamp = datePatternFormat.format(new Date());		if (qw != null) {			long size = ((CountingQuietWriter) qw).getCount();			// if operation fails, do not roll again until maxFileSize more			// bytes are written			nextRollover = size + maxFileSize;		}		File newFile = new File(m_path, logPrefix + datestamp + logSuffix);		fileName = newFile.getAbsolutePath();		super.activateOptions(); // close current file and open new file		nextRollover = 0;		nextCheck = getNextCheckMillis();		LogLog.debug("rollOver finish new file=" + fileName);	}	@Override	protected void setQWForFiles(Writer writer) {		qw = new CountingQuietWriter(writer, errorHandler);	}	protected void cleanupAndRollOver() {		rollOver();		new CleanUpAndCompress().start();	}	private void zipAndDelete(File file) throws IOException {		if (!file.getName().endsWith(".zip")) {			File zipFile = new File(file.getParent(), file.getName().replaceAll(".log", ".zip"));			FileInputStream fis = new FileInputStream(file);			FileOutputStream fos = new FileOutputStream(zipFile);			ZipOutputStream zos = new ZipOutputStream(fos);			ZipEntry zipEntry = new ZipEntry(file.getName());			zos.putNextEntry(zipEntry);			byte[] buffer = new byte[4096];			while (true) {				int bytesRead = fis.read(buffer);				if (bytesRead == -1) {					break;				} else {					zos.write(buffer, 0, bytesRead);				}			}			zos.closeEntry();			fis.close();			zos.close();			file.delete();			LogLog.debug("zipAndDelete finish new zip file=" + zipFile.getName());		}	}	public boolean shouldCompress() {		return compressBackups;	}	class StartsWithFileFilter implements FileFilter {		private String startsWith;		private boolean inclDirs = false;		public StartsWithFileFilter(String startsWith, boolean includeDirectories) {			super();			this.startsWith = startsWith.toUpperCase();			inclDirs = includeDirectories;		}		@Override		public boolean accept(File pathname) {			if (!inclDirs && pathname.isDirectory()) {				return false;			} else {				return pathname.getName().toUpperCase().startsWith(startsWith);			}		}	}	class CleanUpAndCompress extends Thread {		SimpleDateFormat datePatternFormatOnCleanUpAndCompress = new SimpleDateFormat("_yyyyMMdd_HHmmss", Locale.ENGLISH);		private synchronized void cleanUpAndCompress() {			File logFolder = new File(logDirectory);			Calendar cal = Calendar.getInstance();			cal.add(Calendar.DATE, -getMaxNumberOfDays());			Date cutoffDate = cal.getTime();			if (logFolder.exists()) {				File[] files = logFolder.listFiles(new StartsWithFileFilter(logPrefix, false));				for (File file : files) {					try {						String currentFileName = file.getName();						// date pattern size 16 file suffix 4 16 + 4 = 20 is						// pattern+suffix _yyyyMMdd_HHmmss.log						String curretFilePrefixName = currentFileName.substring(0, currentFileName.length() - 20);						// Current file must be pass and be equal logPrefix						if (fileName.equalsIgnoreCase(file.getAbsolutePath()) || !curretFilePrefixName.equalsIgnoreCase(logPrefix)) {							continue;						}						currentFileName = currentFileName.substring(currentFileName.length() - 20, currentFileName.length() - 4);						Date date = datePatternFormatOnCleanUpAndCompress.parse(currentFileName);						if (date.before(cutoffDate)) {							file.delete();						}						// If we're supposed to zip files and this isn't already						// a						// zip						else if (shouldCompress()) {							zipAndDelete(file);						}					} catch (Exception e) {						e.printStackTrace();					}				}			}		}		@Override		public void run() {			cleanUpAndCompress();		}	}}